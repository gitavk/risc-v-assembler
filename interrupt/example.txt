Требуется написать программу, которая: 

* реализует функцию-обработчик (метка *on_event*) прерывания в виде вызываемой процедуры; 
* в метке *load* подключает обработчик, размещая его адрес в таблице обработчиков, дописывая строку в ближайшую свободную строку (гарантируется, что хотя бы одна такая есть); 
* в рамках обработчика реализует вычисления согласно заданию, а также обновление счетчика вызовов в таблице; 
* в метке *unload* отключает обработчик (удаляя его строку из таблицы). 


В качестве **исходных данных** дается стартовый адрес таблицы обработчиков (в метке *listener_table*), а также формула для вычислений с аргументами. Таблица обработчиков имеет вид массива с элементами по 10 байт следующей структуры: 

| Адрес | Описание | Описание | |:------|:-------------------------------|:---------------------------------------------------------| 
| 0 | Не используется (6 байт) | Количество строк в таблице не считая заголовок (4 байта) | 
| 10 | Адрес обработчика №1 (8 байт) | Количество вызовов обработчика №1 (2 байта) | 
| ... | ... | ... | 
| 10*N | Адрес обработчика № N (8 байт) | Количество вызовов обработчика № N (2 байта) | 



Обработчик должен иметь метку *on_event*. Аргументы обработчика передаются через три адреса в памяти, задаваемые метками *a*,*b*,*c*. Результат выполнения обработчика должен быть размещен в регистре *a0*. Обработчик должен самостоятельно увеличивать счетчик вызовов из таблицы обработчиков. 



Ваша программа должна иметь следующую структуру: 

``` 

.globl load 
.globl unload 

load: 
# подключите ваш обработчик события 
ret 


# ваш обработчик события для нажатия на кнопку 
on_event: # Обработайте событие 
... 
ret 



unload: # Отключите ваш обработчик (если он содержится в таблице)
... 
ret 

``` 

Ваше выражение: a & (b | c)





.text

on_event:

# обноление счетчика

la a0, listener_table   # a0 <- адрес таблицы
li a1, 10               # a1 <- 10
la a2, n                # a2 <- n
lw a2, 0(a2)            # a2 <- a2[0]
mul a1, a2, a1          # a1 *= a2
add a1, a1, a0          # a1 += a0
lh a2, 8(a1)            # a2 <- a1[8]
addi a2, a2, 1          # a2++
sh a2, 8(a1)            # a1[8] <- a2

# вычисления a & (b | c)

la a0, a               # a0 <- a
la a1, b               # a1 <- b
la a2, c               # a2 <- c
ld a0, 0(a0)           # a0 <- a0[0]
ld a1, 0(a1)           # a1 <- a1[0]
ld a2, 0(a2)           # a2 <- a2[0]
   
or a1, a1, a2          # a1 |= a2
and a0, a0, a1         # a0 &= a1

ret

load:

la a6, n # увеличение listener_table.n + сохренение в локальную "n"
la a5, listener_table  # a5 <- адрес таблицы
lw a4, 6(a5)           # a4 <- a5[6]
addiw a4, a4, 1        # a4++
sw a4, 0(a6)           # a6[0] <- a4
sw a4, 6(a5)           # a5[6] <- a4

li a6, 10 # a5 = listener_table.data[n]
mul a4, a4, a6
add a5, a5, a4    # a5 += a4 * a6
la a4, on_event   # установить адрес функции
sd a4, 0(a5)      # a5[0] <- a4
sh zero, 8(a5)    # сбросить счетчик

ret

unload:

la a5, listener_table # уменьшение listener_table.n
lw a4, 6(a5)      # a4 <- a5[6]
addiw a4, a4, -1  # a4--
sw a4, 6(a5)      # a5[6] <- a4

ret



.data

n: .zero   0        # глобальная переменная: значение счетчика вызовов прерываний

.globl load
.globl unload
