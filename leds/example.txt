Предположим, что сгенерированное задание имеет следующий вид:

 

Инициализация задания lab5_daemon с seed=...

Требуется написать программу, которая
* реализует цикл активного ожидания для обработки событий;
* в рамках цикла отслеживает состояние кнопок и также изменяет состояние светодиодов.

В качестве исходных данных дается правило, по которому необходимо зажигать светодиоды в зависимости от состояний кнопок. Изначально все светодиоды выключены.

Считаем, что в системе есть 8 светодиодов и 8 кнопок. Кнопки и светодиоды нумеруются с нуля. У каждого светодиода и кнопки есть бинарное состояние, задаваемое через int:
1 - светодиод горит (кнопка нажата),
0 - светодиод не горит (кнопка не нажата).



Вспомогательные процедуры, которые вам необходимо использовать:

int get_button_status (int button_number)
void set_led_status (int led_number, int led_status)
void delay()


Ваша программа должна иметь следующую структуру:



```

.globl solution
solution:


ret

```


Ваше задание:

Y0 = X3 | (X2 ^ X0) 
Y1 = (X1 ^ (X7 | (not X1))) 
Y2 = (X6 ^ (X7 | X5)) 
Y3 = X4 ^ (X2 | (not X4)) 
Y4 = (X5 & (X2 | X2)) 
Y5 = (X0 | (X0 ^ X6)) 
Y6 = ((not X4) | (X1 ^ (not X0))) 
Y7 = (X5 & X3) & X6

 

Некоторые выражения можно сразу упростить:

 

Y1 = -(X1 & X7)
Y3 = -(X4 & X2)
Y4 = X5 & X2
Y5 = X0 | X6

 

Упрощение остальных выражений не представляется возможным, так как используемые в вычислениях переменные не повторяются.

Пример программы, которая решает поставленную задачу, выглядит следующим образом:

 

.globl solution

solution:

# a0 - номер светодиода / кнопки или считанное состояние кнопки
# a1 - состояние светодиода



#s10 - состояние кнопок
#s11 - состояние светодиодов
#s8 = 8
#s9 - счетчик



li s8, 8            # s8 <- 8

init:

mv s9, zero
mv s10, zero
mv s11, zero        # s9, s10, s11 <- 0

loop_bt:

mv a0, s9           # a0 <- номер кнопки
call get_button_status # a0 <- состояние кнопки
    
sll t0, a0, s9      # t0 = a0 << s9
or s10, s10, t0     # s10 |= t0

addi s9, s9, 1      # номер следующей кнопки
blt s9, s8, loop_bt # обработка следующей кнопки

srli t0, s10, 3     # t0 <- s10 >> 3
andi t0, t0, 1      # t0 &= 1
srli t1, s10, 2     # t1 <- s10 >> 2
andi t1, t1, 1      # t1 &= 1
srli t2, s10, 0     # t2 <- s10 >> 0
andi t2, t2, 1      # t2 &= 1
xor s0, t1, t2      # s0 <- t1 ^ t2
or s0, t0, s0       # s0 <- t0 | s0
andi s0, s0, 1      # s0 <- s0 & 1
slli s0, s0, 0      # s0 <- s0 << 0
or s11, s11, s0     # s11 |= s0

srli t0, s10, 1     # t0 <- s10 >> 1
andi t0, t0, 1      # t0 &= 1
srli t1, s10, 7     # t1 <- s10 >> 7
andi t1, t1, 1      # t1 &= 1
and s0, t0, t1      # s0 <- t0 & t1
xori s0, s0, 1      # s0 ^= 1
andi s0, s0, 1      # s0 &= 1
slli s0, s0, 1      # s0 <- s0 << 1
or s11, s11, s0     # s11 |= s0

srli t0, s10, 6     # t0 <- s10 >> 6
andi t0, t0, 1      # t0 &= 1
srli t1, s10, 7     # t1 <- s10 >> 7
andi t1, t1, 1      # t1 &= 1
srli t2, s10, 5     # t2 <- s10 >> 5
andi t2, t2, 1      # t2 &= 1
or s0, t1, t2       # s0 <- t1 | t2
xor s0, t0, s0      # s0 ^= t0
andi s0, s0, 1      # s0 &= 1
slli s0, s0, 2      # s0 <- s0 << 2
or s11, s11, s0     # s11 |= s0

srli t0, s10, 4     # t0 <- s10 >> 4
andi t0, t0, 1      # t0 &= 1
srli t1, s10, 2     # t1 <- s10 >> 2
andi t1, t1, 1      # t1 &= 1
and s0, t0, t1      # s0 <- t0 & t1
xori s0, s0, 1      # s0 ^= 1
andi s0, s0, 1      # s0 &= 1
slli s0, s0, 3      # s0 <- s0 << 3
or s11, s11, s0     # s11 |= s0

srli t0, s10, 5     # t0 <- s10 >> 5
andi t0, t0, 1      # t0 &= 1
srli t1, s10, 2     # t1 <- s10 >> 2
andi t1, t1, 1      # t1 &= 1
and s0, t0, t1      # s0 <- t0 & t1
andi s0, s0, 1      # s0 &= 1
slli s0, s0, 4      # s0 <- s0 << 4
or s11, s11, s0     # s11 |= s0

srli t0, s10, 0     # t0 <- s10 >> 0
andi t0, t0, 1      # t0 &= 1
srli t1, s10, 6     # t1 <- s10 >> 6
andi t1, t1, 1      # t1 &= 1
or s0, t0, t1       # s0 <- t0 | t1
andi s0, s0, 1      # s0 &= 1
slli s0, s0, 5      # s0 <- s0 << 5
or s11, s11, s0     # s11 |= s0

srli t0, s10, 4     # t0 <- s10 >> 4
xori t0, t0, 1      # t0 ^= 1
srli t1, s10, 1     # t1 <- s10 >> 1
andi t1, t1, 1      # t1 &= 1
srli t2, s10, 0     # t2 <- s10 >> 0
xori t2, t2, 1      # t2 ^= 1
xor s0, t1, t2      # s0 = t1 ^ t2
or s0, t0, s0       # s0 |= t0
andi s0, s0, 1      # s0 &= 1
slli s0, s0, 6      # s0 <- s0 << 6
or s11, s11, s0     # s11 |= s0

srli t0, s10, 5     # t0 <- s10 >> 5
andi t0, t0, 1      # t0 &= 1
srli t1, s10, 3     # t1 <- s10 >> 3
andi t1, t1, 1      # t1 &= 1
srli t2, s10, 6     # t2 <- s10 >> 6
andi t2, t2, 1      # t2 &= 1
and s0, t0, t1      # s0 <- t0 & t1
and s0, s0, t2      # s0 <- s0 & t2
andi s0, s0, 1      # s0 &= 1
slli s0, s0, 7      # s0 <- s0 << 7
or s11, s11, s0     # s11 |= s0

mv s9, zero         # s9 <- 0
mv t0, s11          # t0 <- s11

loop_leds:

mv a0, s9           # a0 <- s9
andi a1, t0, 1      # a1 <- младший бит t0
call set_led_status # зажечь светодиод
addi s9, s9, 1      # номер следующего светодиода
srli t0, t0, 1      # t0 >>= 1
blt s9, s8, loop_leds   # обработка следующего светодиода

call delay              #задержка

j init                  # переход в начало цикла активного ожидания 
